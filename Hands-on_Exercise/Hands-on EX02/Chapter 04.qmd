---
title: "Hands-0n Exercise 2A"
author: "Kalpit Kulshrestha"
---

# First-order Spatial Point Patterns Analysis Methods

## Data source

The Child care service data is from data.gov.sg and aster Plan 2019 Subzone Boundary (No Sea) is from another source.

## Installing and loading some new packages

```{r}
pacman::p_load(sf, terra, spatstat, 
               tmap, rvest, tidyverse)
```

## importing and Wrangling Geospaitial data

```{r}
mpsz_sf <- st_read("K:/kalpitkulshrestha24/ISSS626/Hands-on_Exercise/Hands-on EX02/data/Geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml") %>% 
  st_zm(drop = TRUE, what = "ZM") %>% st_transform(crs = 3414)
```

```{r}
extract_kml_field <- function(html_text, field_name) {
  if (is.na(html_text) || html_text == "") return(NA_character_)
  
  page <- read_html(html_text)
  rows <- page %>% html_elements("tr")
  
  value <- rows %>%
    keep(~ html_text2(html_element(.x, "th")) == field_name) %>%
    html_element("td") %>%
    html_text2()
  
  if (length(value) == 0) NA_character_ else value
}
```

```{r}
mpsz_sf <- mpsz_sf %>%
  mutate(
    REGION_N = map_chr(Description, extract_kml_field, "REGION_N"),
    PLN_AREA_N = map_chr(Description, extract_kml_field, "PLN_AREA_N"),
    SUBZONE_N = map_chr(Description, extract_kml_field, "SUBZONE_N"),
    SUBZONE_C = map_chr(Description, extract_kml_field, "SUBZONE_C")
  ) %>%
  select(-Name, -Description) %>%
  relocate(geometry, .after = last_col())

```

```{r}
mpsz_cl <- mpsz_sf %>%
  filter(SUBZONE_N != "SOUTHERN GROUP",
         PLN_AREA_N != "WESTERN ISLANDS",
         PLN_AREA_N != "NORTH-EASTERN ISLANDS")
```

```{r}
write_rds(mpsz_cl, 
          "K:/kalpitkulshrestha24/ISSS626/Hands-on_Exercise/Hands-on EX02/data/GEospatial/mpsz_cl.rds")

```

### Importing and loading Child care service data

```{r}
childcare_sf <- st_read("K:/kalpitkulshrestha24/ISSS626/Hands-on_Exercise/Hands-on EX02/data/Aspatial/ChildCareServices.kml") %>% 
  st_zm(drop = TRUE, what = "ZM") %>%
  st_transform(crs = 3414)
```

```{r}
st_crs(mpsz_cl)
```

```{r}
st_crs(childcare_sf)
```

### Mapping the geospatial data

```{r}
plot(st_geometry(mpsz_cl))
plot(st_geometry(childcare_sf), add = TRUE)
```

```{r}
tmap_mode('view')
tm_shape(childcare_sf)+
  tm_dots()
```

## Geospatial Data Wrangling

using specific data structures like ppp(planar point pattern)

### Converting sf data frames to *ppp* class

spatstat will use the point event data in ppp object form using *\[ as.ppp()\]* of spatstat package to convert childcare_sf to ppp format.

```{r}
childcare_ppp <- as.ppp(childcare_sf)
```

```{r}
class(childcare_ppp)
```

```{r}
summary(childcare_ppp)
```

### Creating *owin* object

```{r}
sg_owin <- as.owin(mpsz_cl)
```

```{r}
class(sg_owin)
```

```{r}
plot(sg_owin)
```

### Combining point events object and *owin* object

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
```

```{r}
childcareSG_ppp
```

## Clark-Evan Test for Nearest Neighbour Analysis

a spatial statistics method that calculates the average distance between each point and its closest neighbor to determine if a pattern of points is clustered, dispersed, or randomly distributed.

The test hypotheses are:

Ho = The distribution of childcare services are randomly distributed.

H1= The distribution of childcare services are not randomly distributed.

The 95% confident interval will be used.

### perfromin the Clark-Evans test without CSR

```{r}
clarkevans.test(childcareSG_ppp, correction = "none", clipregion = "sg_owin", alternative = c("clustered"))
```

Statistical Conclusion:

Business Insights from above analysis:

### Performing Clark_Evans with CSR

```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                method="MonteCarlo",
                nsim=99)
```

Statistical Conclusion:

Business Insights:

## Kernal Density Estimation Method

### Working with automatic bandwidth selection method

```{r}
kde_SG_diggle <- density(
  childcareSG_ppp,
  sigma=bw.diggle,
  edge=TRUE,
  kernel="gaussian") 
```

```{r}
plot(kde_SG_diggle)
```

```{r}
summary(kde_SG_diggle)
```

we are retrieving the bandwidth which used to compute the kde layer.

```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

### Rescalling KDE values

```{r}
childcareSG_ppp_km <- rescale.ppp(
  childcareSG_ppp, 1000, "km")
```

```{r}
kde_childcareSG_km <- density(childcareSG_ppp_km,
                              sigma=bw.diggle,
                              edge=TRUE,
                              kernel="gaussian")
```

```{r}
plot(kde_childcareSG_km)
```

### working with different automatic bandwidth methods

```{r}
bw.CvL(childcareSG_ppp_km)
```

```{r}
bw.scott(childcareSG_ppp_km)
```

```{r}
bw.ppl(childcareSG_ppp_km)
```

```{r}
bw.diggle(childcareSG_ppp_km)
```

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp_km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG_km, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```

### Working with differnet kernel methods

```{r}
par(mfrow=c(2,2))
plot(density(childcareSG_ppp_km, 
             sigma=0.2959712, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp_km, 
             sigma=0.2959712, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp_km, 
             sigma=0.2959712, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp_km, 
             sigma=0.2959712, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

# Fixed and adaptive KDE

## Computing KDE bu using fixed bandwidth
We will compute a KDE layer by defining a bandwidth of 600 meter. Notice that in the code chunk below, the sigma value used is 0.6. This is because the unit of measurement of childcareSG_ppp_km object is in kilometer, hence the 600m is 0.6km.

```{r}
kde_childcareSG_fb <- density(childcareSG_ppp_km,
                              sigma=0.6, 
                              edge=TRUE,
                              kernel="gaussian")
plot(kde_childcareSG_fb)
```
## Computing KDE by using adaptive bandwidth

Fixed bandwidth method is very sensitive to highly skew distribution of spatial point patterns over geographical units for example urban versus rural. One way to overcome this problem is by using adaptive bandwidth instead.

In this section, you will learn how to derive adaptive kernel density estimation by using density.adaptive() of spatstat.

```{r}
kde_childcareSG_ab <- adaptive.density(
  childcareSG_ppp_km, 
  method="kernel")
plot(kde_childcareSG_ab)
```
Now, comparing both KDE fixed and adaptive.

```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG_fb, main = "Fixed bandwidth")
plot(kde_childcareSG_ab, main = "Adaptive bandwidth")
```
# Plotting cartographic quality KDE map

## Converting gridded output into raster
```{r}
kde_childcareSG_bw_terra <- rast(kde_childcareSG_km)
```

```{r}
class(kde_childcareSG_bw_terra)
```
```{r}
kde_childcareSG_bw_terra
```
## Assigning projection systems
```{r}
crs(kde_childcareSG_bw_terra) <- "EPSG:3414"
```

```{r}
kde_childcareSG_bw_terra
```
##  Plotting KDE map with tmap

```{r}
tm_shape(kde_childcareSG_bw_terra) + 
  tm_raster(col.scale = 
              tm_scale_continuous(
                values = "viridis"),
            col.legend = tm_legend(
            title = "Density values",
            title.size = 0.7,
            text.size = 0.7,
            bg.color = "white",
            bg.alpha = 0.7,
            position = tm_pos_in(
              "right", "bottom"),
            frame = TRUE)) +
  tm_graticules(labels.size = 0.7) +
  tm_compass() +
  tm_layout(scale = 1.0)
```



# First Order SPPA at the Planning Subzone Level

## Geospatial data wrangling

### Extracting Study area
```{r}
pg <- mpsz_cl %>%
  filter(PLN_AREA_N == "PUNGGOL")
tm <- mpsz_cl %>%
  filter(PLN_AREA_N == "TAMPINES")
ck <- mpsz_cl %>%
  filter(PLN_AREA_N == "CHOA CHU KANG")
jw <- mpsz_cl %>%
  filter(PLN_AREA_N == "JURONG WEST")
```

```{r}
par(mfrow=c(1,1))
plot(st_geometry(pg), main = "Ponggol")
plot(st_geometry(tm), main = "Tampines")
plot(st_geometry(ck), main = "Choa Chu Kang")
plot(st_geometry(jw), main = "Jurong West")
```
### Creating OWIN Object
```{r}
pg_owin = as.owin(pg)
tm_owin = as.owin(tm)
ck_owin = as.owin(ck)
jw_owin = as.owin(jw)
```

### Combining point events object and owin object
```{r}
childcare_pg_ppp = childcare_ppp[pg_owin]
childcare_tm_ppp = childcare_ppp[tm_owin]
childcare_ck_ppp = childcare_ppp[ck_owin]
childcare_jw_ppp = childcare_ppp[jw_owin]
```

```{r}
childcare_pg_ppp.km = rescale.ppp(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale.ppp(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale.ppp(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale.ppp(childcare_jw_ppp, 1000, "km")
```

```{r}
par(mfrow=c(1,1))
plot(unmark(childcare_pg_ppp.km), 
  main="Punggol")
plot(unmark(childcare_tm_ppp.km), 
  main="Tampines")
plot(unmark(childcare_ck_ppp.km), 
  main="Choa Chu Kang")
plot(unmark(childcare_jw_ppp.km), 
  main="Jurong West")
```
## Clark and EVans Test
```{r}












