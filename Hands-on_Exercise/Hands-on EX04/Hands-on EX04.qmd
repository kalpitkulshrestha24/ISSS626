---
title: "Hands-on EX04"
author: "Kalpit Kulshrestha"
---

# Spatial Weights and Application

## Overview

in this Hands-on exercise 04, we will learn and how to compute spatial weights using R. where we use following packages.

-   import geospatial data using appropriate funtions of **sf** packages.
-   import csv file using appropriate function of **readr** package.
-   perform relational join using appropriate join function of **dplyr** package.
-   compute spatial weights using appropriate function of **spdep** package, and
-   calculate spatially lagged variables using appropriate functions of spdep packages.

## the study area and data

2 dataset are here for this hands on exercise.

-   Hunan county boundary layer. this is geospatial data set in ESRI shapefile format.
-   *Hunan_2012.csv*. this csv file contains selected Human's local development indicators in 2012.

### Installing packages

here, I am installing following packages that spdep, sf, tmap and tidyverse packages of R are currently installed in your R.

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

*Succesfully installed all packages in the enviroment.*

## Getting the data into R

### Import shapefile into R

we uses `st_read()` of **sf** packages to import Hunan shapefile into R. The imported shapefile will be simple features object of **sf**.

```{r}
hunan <- st_read(dsn = "K:/kalpitkulshrestha24/ISSS626/Hands-on_Exercise/Hands-on EX04/data/geospatial",
                 layer = "Hunan")
```

### Import CSV file into R environment

*Hunan_2012.csv* file into R using *read_csv()* of readr packages.

```{r}
hunan2012 <- read_csv("K:/kalpitkulshrestha24/ISSS626/Hands-on_Exercise/Hands-on EX04/data/aspatial/Hunan_2012.csv")
```

Above, i listed out the column list with what kinf of column type it is. so that I know what I am using for this hands on exercise

### Perfroming relational join

To update the attribute table of hunan’s SpatialPolygonsDataFrame with the attribute fields of hunan2012 dataframe. This is performed by using left_join() of dplyr package.

```{r}
hunan <- left_join(hunan, hunan2012) %>%
  select(1:4,7, 15)
```

## Visualising Regional Development Indicator

we are going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using *qtm()* of **tmap()** packages.

```{r}
basemap <- tm_shape(hunan) +
  tm_polygons() + 
  tm_text("NAME_3", size =0.5)

gdppc <- qtm(hunan, "GDPPC") +
  tm_layout(
    legend.position = c("left","bottom"))
tmap_arrange(basemap, gdppc, asp=1, ncol=2)
```

## Computing Contiguity Spatial Weights

here, I am using `poly2nb()` of **spdep** package to compute contiguity weight matrices for the study area.This function builds a neighbours list based on regions with contiguous boundaries. If you look at the documentation you will see that you can pass a “queen” argument that takes TRUE or FALSE as options. If you do not specify this argument the default is set to TRUE, that is, if you don’t specify queen = FALSE this function will return a list of first order neighbours using the Queen criteria.

### Computing (Queen) contiguity based neighbours

```{r}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```
The summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area units with only one heighbours.

to see the neighbours for the first polygon in the object:
```{r}
wm_q[[1]]
```
Polygon 1 has 5 neighbors. The numbers represent the polygon IDs as stored in hunan SpatialPolygonsDataFrame class.

We can retrive the county name of Polygon ID=1 by using the code chunk below:
```{r}
hunan$County[1]
```
The output reveals that Polygon ID=1 is Anxiang county.

To reveal the county names of the five neighboring polygons, the code chunk will be used:

```{r}
hunan$NAME_3[c(2,3,4,57,85)]
```
we can retrieve the GDPPC of the these 5 countries by using the below code.
```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```
The printed output above shows that the GDPPC of the five nearest neighbours based on Queen’s method are 20981, 34592, 24473, 21311 and 22879 respectively.

You can display the complete weight matrix by using str().

```{r}
str(wm_q)
```
### Creating(ROOK) contiguity based neighbours
```{r}
wm_r <- poly2nb(hunan,queen=FALSE)
summary(wm_q)
```
The summary report above shows that there are 88 area units in Hunan. The most connect area unit has 10 neighbours. There are two area units with only one neighbours.

### Visualising contiguity weights



```{r}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
```

```{r}
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
```

```{r}
coords <- cbind(longitude, latitude)
```

```{r}
head(coords)
```
#### plotting Queen Contiguity based neighbours map
```{r}
plot(hunan$geometry, border = "lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
```
#### plotting Rook contiguity based neighbours map
```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```
#### plotting both Queen and Rook 

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey", main="Queen Contiguity")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
plot(hunan$geometry, border="lightgrey", main="Rook Contiguity")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```
## Computing distance based neighbours
we are using `dnearneigh()` of **spdep** package.

:::callour-note
The function identifies neighbours of region points by Euclidean distance with a distance band with lower d1= and upper d2= bounds controlled by the bounds= argument. If unprojected coordinates are used and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in km will be calculated assuming the WGS84 reference ellipsoid.
:::
### Determine the cut-off distance

determinng the upper limit for distance band

- Return a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using knearneigh() of spdep.
- Convert the knn object returned by knearneigh() into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using knn2nb().
- Return the length of neighbour relationship edges by using nbdists() of spdep. The function returns in the units of the coordinates if the coordinates are projected, in km otherwise.
- Remove the list structure of the returned object by using unlist().

```{r}
#coords <- coordinates(hunan)
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```
### Computing fixed distance weight matrix
```{r}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62
```
**Quiz:** what is the meaning if "Average number of links: 3.681818" shown above?

*The value “Average number of links: 3.681818” means that, based on your chosen distance threshold (0–62 units), each of the 88 regions has on average about 3.68 neighbouring regions. In other words, every region is connected to roughly 3–4 other regions within that distance band, showing the average spatial connectivity (or density of neighbour relationships) across the whole study area.*

```{r}
str(wm_d62)
```

```{r}
table(hunan$County, card(wm_d62))
```

```{r}
n_comp <- n.comp.nb(wm_d62)
n_comp$nc
```
```{r}
table(n_comp$comp.id)
```

#### plotting fixed distance weight matrix
```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE)
plot(k1, coords, add=TRUE, col="red", length=0.08)
```
The red lines show the links of 1st nearest neighbours and the black lines show the links of neighbours within the cut-off distance of 62km.

Alternatively, we can plot both of them next to each other by using the code chunk below.
```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey", main="1st nearest neighbours")
plot(k1, coords, add=TRUE, col="red", length=0.08)
plot(hunan$geometry, border="lightgrey", main="Distance link")
plot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6)
```
### Computing adaptive distance weight matrix

```{r}
knn6 <- knn2nb(knearneigh(coords, k=6))
knn6
```
```{r}
str(knn6)
```
#### plotting distance based neighbours

```{r}
plot(hunan$geometry, border="lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```
## weights based on IDW
 we will compute the distances between areas by using `nbdists()` of **spdep**.

```{r}
dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
ids
```

## Row-standardised weight matrix


```{r}
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q
```
The zero.policy=TRUE option allows for lists of non-neighbors. This should be used with caution since the user may not be aware of missing neighbors in their dataset however, a zero.policy of FALSE would return an error.

```{r}
rswm_q$weights[10]
```
Each neighbor is assigned a 0.125 of the total weight. This means that when R computes the average neighboring income values, each neighbor’s income will be multiplied by 0.125 before being tallied.

Using the same method, we can also derive a row standardised distance weight matrix by using the code chunk below.


```{r}
rswm_ids <- nb2listw(wm_q, glist=ids, style="B", zero.policy=TRUE)
rswm_ids
```
```{r}
rswm_ids$weights[1]
```
```{r}
summary(unlist(rswm_ids$weights))
```
## Application of spatial weight Matrix
we'll compute the average neighbor GDPPC value for each polygon. These values are often reffered as spatially lagged values.

```{r}
GDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)
GDPPC.lag
```
```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```
```{r}
lag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))
lag.res <- as.data.frame(lag.list)
colnames(lag.res) <- c("NAME_3", "lag GDPPC")
hunan <- left_join(hunan,lag.res)
```
```{r}
head(hunan)
```
we plot both the GDPPC and spatial lag GDPPc for comparison.
```{r}
gdppc <- qtm(hunan, "GDPPC")
lag_gdppc <- qtm(hunan, "lag GDPPC")
tmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)
```
### spatial lag as a sum of neighboring values
we can calculate spatial lag as sum of neighboring values by assisng binary weights. here, we use glist-in the nb2listw function to explicitly assigne the weights.
```{r}
b_weights <- lapply(wm_q, function(x) 0*x + 1)
b_weights2 <- nb2listw(wm_q, 
                       glist = b_weights, 
                       style = "B")
b_weights2
```
With the proper weights assigned, we can use lag.listw to compute a lag variable from our weight and GDPPC.
```{r}
lag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
lag.res <- as.data.frame(lag_sum)
colnames(lag.res) <- c("NAME_3", "lag_sum GDPPC")
```
```{r}
lag_sum
```
```{r}
hunan <- left_join(hunan, lag.res)
```
```{r}
gdppc <- qtm(hunan, "GDPPC")
lag_sum_gdppc <- qtm(hunan, "lag_sum GDPPC")
tmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)
```
### spatial window average
To add the diagonal element to the neighbour list, we just need to use `include.self()` from **spdep**.

```{r}
wm_qs <- include.self(wm_q)
```

```{r}
wm_qs[[1]]
```
```{r}
wm_qs <- nb2listw(wm_qs)
wm_qs
```
Again, we use nb2listw() and glist() to explicitly assign weight values.

Lastly, we just need to create the lag variable from our weight structure and GDPPC variable.

```{r}
lag_w_avg_gpdpc <- lag.listw(wm_qs, 
                             hunan$GDPPC)
lag_w_avg_gpdpc
```
```{r}
lag.list.wm_qs <- list(hunan$NAME_3, lag.listw(wm_qs, hunan$GDPPC))
lag_wm_qs.res <- as.data.frame(lag.list.wm_qs)
colnames(lag_wm_qs.res) <- c("NAME_3", "lag_window_avg GDPPC")
```

```{r}
hunan <- left_join(hunan, lag_wm_qs.res)
```
```{r}
hunan %>%
  select("County", 
         "lag GDPPC", 
         "lag_window_avg GDPPC") %>%
  kable()
```
plotting a maap for both lag_gdppc and w_ave_gdppc maps next o each other for quick comparison.

```{r}
w_avg_gdppc <- qtm(hunan, "lag_window_avg GDPPC")
tmap_arrange(lag_gdppc, w_avg_gdppc, asp=1, ncol=2)
```
### spatial window sum

```{r}
wm_qs <- include.self(wm_q)
wm_qs
```
```{r}
b_weights <- lapply(wm_qs, function(x) 0*x + 1)
b_weights[1]
```
```{r}
b_weights2 <- nb2listw(wm_qs, 
                       glist = b_weights, 
                       style = "B")
b_weights2
```

```{r}
w_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
w_sum_gdppc
```
```{r}
w_sum_gdppc.res <- as.data.frame(w_sum_gdppc)
colnames(w_sum_gdppc.res) <- c("NAME_3", "w_sum GDPPC")
```

```{r}
hunan <- left_join(hunan, w_sum_gdppc.res)
```
```{r}
hunan %>%
  select("County", "lag_sum GDPPC", "w_sum GDPPC") %>%
  kable()
```
```{r}
w_sum_gdppc <- qtm(hunan, "w_sum GDPPC")
tmap_arrange(lag_sum_gdppc, w_sum_gdppc, asp=1, ncol=2)
```














